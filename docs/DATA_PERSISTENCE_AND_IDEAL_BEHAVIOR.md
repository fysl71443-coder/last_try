# استمرارية البيانات وسلوك النظام المثالي

## 1. كيف يجب أن يعمل النظام المثالي

### 1.1 الحفظ التلقائي (Auto-save)

- **أي تعديل** يقوم به المستخدم يجب أن يُحفظ تلقائياً في الجدول المرتبط مباشرة عند كل عملية إضافة/تعديل.
- **مثال:** إضافة وجبة → تُحفظ في `menu_items` (أو الجدول المعتمد) مباشرة بعد النقر على «حفظ» أو عند الخروج من الحقل (حسب تصميم الواجهة).
- **لا يعتمد** الحفظ على إعادة تحميل الصفحة أو إغلاق المتصفح — بل على استدعاء API/مسار يحفظ في قاعدة البيانات ثم يستدعي `db.session.commit()`.

### 1.2 تغيير الموديل (Schema) بدون فقدان البيانات

- عند **تعديل الـ schema** (إضافة/إعادة تسمية/حذف حقول):
  - يجب إنشاء **migration** ينقل البيانات القديمة إلى الحقول الجديدة.
  - **لا يجوز** حذف الحقول القديمة إلا بعد ترحيل البيانات والتأكد من أن كل البيانات محفوظة في الجدول/الحقول الجديدة.

### 1.3 التراجع فقط بإرادة المستخدم

- زر **«تراجع»** أو **«إعادة تعيين»** يتيح الرجوع إلى الحالة السابقة (مثلاً إعادة تحميل من الخادم أو استرجاع نسخة محفوظة).
- **النظام لا يقوم بالتراجع تلقائياً** عند إعادة تحميل الشاشة أو تغيير الموديل — أي تراجع يكون بفعل المستخدم فقط.

### 1.4 مراجعة جميع العمليات (سداد، تحصيل، إيداع، سحب)

| العملية | الربط / الاستعلام | التعديل |
|---------|-------------------|----------|
| **سداد — مورد** | `api_operations_outstanding`: عرض فواتير مشتريات/مصروفات غير مسددة للمورد. | الربط بـ `supplier_id` (من القائمة) و/أو `supplier_name`؛ تمرير `party_id` من الواجهة. `api_quick-txn` (supplier_payment): نفس المطابقة بـ `supplier_id` عند توفره. |
| **سداد — مسير رواتب** | استعلام مسيرات غير مسددة (`/api/unpaid_payroll_runs`)؛ السداد عبر `pay_liability` مع سنة/شهر. | لا تغيير — المطابقة بسنة/شهر. |
| **سداد — مستحقات أخرى / منصة** | رصيد حساب (قيود منشورة) عبر `_account_balance_as_of`. | لا تغيير. |
| **تحصيل — عميل** | عرض فواتير مبيعات غير محصلة للعميل. | الربط بـ `customer_id` (من القائمة) و/أو `customer_name`؛ تمرير `party_id` من الواجهة. |
| **تحصيل — سلفة موظف / أخرى** | قيد تحصيل يخفض رصيد حساب مدينة (1141/1151/1142)؛ لا قائمة فواتير. | لا تغيير. |
| **إيداع** | قيد: مدين بنك، دائن صندوق. | لا تغيير. |
| **سحب** | قيد: مدين رأس المال/مسحوبات، دائن صندوق/بنك. | لا تغيير. |

**ملاحظة:** استعلام المصروفات (ExpenseInvoice) للمورد مُحمى بـ `try/except` و`hasattr(ExpenseInvoice, 'supplier_name')` لتفادي فشل إذا لم يكن الحقل موجوداً في الموديل.

### 1.5 ربط الفاتورة بمستحقات السداد (شاشة سداد المورد)

- عند اختيار **المورد** في شاشة «سداد»، يجب أن يستعلم النظام عن **كل الفواتير غير المسددة** لذلك المورد ويعرضها (رقم الفاتورة، التاريخ، الإجمالي، المدفوع، المتبقي).
- الربط يتم عبر **`supplier_id`** (من جدول الموردين) و/أو **`supplier_name`** في جدول `purchase_invoices`. إذا كانت الفاتورة مرتبطة بالمورد بـ `supplier_id` فقط (والاسم مختلف أو فارغ)، يجب أن تظهر في قائمة المستحقات.
- التطبيق: واجهة `GET /financials/api/operations/outstanding?party_type=supplier&party_name=...&party_id=...` تُرجع فواتير المشتريات (والمصروفات إن وُجدت) للمورد؛ تم تعديل الاستعلام ليشمل المطابقة بـ `PurchaseInvoice.supplier_id` عند تمرير `party_id` (من القائمة)، مع الإبقاء على المطابقة بالاسم. راجع `routes/financials.py` — `api_operations_outstanding`.

### 1.6 حذف القيد = حذف الفاتورة/العملية المرتبطة

- عند **حذف أي قيد محاسبي** (مثلاً JE-EXP-INV-2026-0001) يجب حذف **الفاتورة أو العملية المرتبطة** تلقائياً (مثلاً INV-EXP-2026-0001)، لتفادي بقاء فاتورة بدون قيد — مما يسبب عدم اتساق الحسابات.
- التطبيق: دالة `delete_journal_entry_and_linked_invoice` في `routes/journal.py` تُستدعى من مسار الحذف (صفحة القيود)، وواجهة API حذف القيد، وواجهة API دفتر الأستاذ؛ تحذف كل القيود المرتبطة بنفس الفاتورة (مثلاً قيد المصروف وقيد السداد)، ثم الدفعات، ثم بنود الفاتورة والفاتورة. راجع `docs/ACCOUNTING_AUDIT.md` (القسم 3).

---

## 2. لماذا قد تُفقد التعديلات أو البيانات عند إعادة تشغيل الخادم؟

**السؤال:** أليس من المفترض أن يتم حفظ التعديلات على قاعدة البيانات؟

**الجواب:** نعم — **إذا** تم استدعاء `db.session.commit()` بعد كل تعديل، والاتصال بقاعدة بيانات في **ملف دائم** (وليس في الذاكرة أو ملف مؤقت)، فإن البيانات تبقى بعد إعادة تشغيل الخادم.

فقدان البيانات أو التعديلات يحدث عادة لأحد الأسباب التالية:

### 2.1 عدم استدعاء `commit()` بعد التعديل

- في Flask-SQLAlchemy **لا يتم** الالتزام تلقائياً في نهاية الطلب.
- إذا قام المسار (route) بـ `db.session.add()` أو `db.session.merge()` أو تعديل كائن دون استدعاء `db.session.commit()`، فإن التعديل يبقى في **الـ session** فقط، ولا يُكتب على القرص.
- عند انتهاء الطلب أو إعادة تشغيل الخادم تُفقد هذه التعديلات.

**الحل:** التأكد من استدعاء `db.session.commit()` بعد كل عملية إضافة/تعديل ناجحة في المسار المعني.

### 2.2 استثناء (Exception) قبل `commit()`

- إذا حدث خطأ بعد `add()` وقبل `commit()`، ولم يُعالَج الطلب بإجراء `commit()` في مسار بديل (مثلاً في `try/except`)، فإن الجلسة قد تُرجع (rollback) أو تُغلق دون حفظ.

**الحل:** استخدام `try/except` وضمان استدعاء `commit()` في مسار النجاح، واستدعاء `rollback()` في مسار الفشل ثم إعادة رفع الاستثناء أو إرجاع رسالة خطأ للمستخدم.

### 2.3 استخدام قاعدة بيانات في الذاكرة أو مؤقتة

- إذا كان `SQLALCHEMY_DATABASE_URI` يشير إلى:
  - `sqlite:///:memory:` → كل البيانات في الذاكرة وتُمسح عند إعادة تشغيل العملية.
  - مسار في `/tmp` أو مجلد مؤقت → قد يُمسح عند إعادة التشغيل أو بإعادة تشغيل النظام.

**الحل:** استخدام مسار **ثابت** داخل المشروع (مثل `instance/accounting_app.db` أو ما يُعرّف عبر `LOCAL_SQLITE_PATH`). راجع `config.py` و`docs/SQLITE_PERSISTENCE.md`.

### 2.4 تشغيل التطبيق من مجلد عمل (cwd) مختلف

- إذا كان مسار قاعدة البيانات **نسبياً** (مثل `instance/accounting_app.db`) وكان الخادم يُشغّل من مجلد مختلف عن جذر المشروع، فقد يُنشأ ملف DB في مكان آخر أو يُقرأ ملف مختلف.

**الحل:** استخدام مسار **مطلق** لملف SQLite (كما في `config.py`: `os.path.join(_project_root, 'instance', 'accounting_app.db')`) أو التأكد من أن `cwd` ثابت عند التشغيل.

### 2.5 حفظ «تعديلات» فقط في الواجهة (Frontend) أو الجلسة (Session)

- إذا كانت التعديلات تُحفظ في:
  - **JavaScript (state فقط)** دون إرسال طلب حفظ إلى الخادم، أو
  - **Flask session** (في الذاكرة أو ملف cookie) دون كتابة في جدول في قاعدة البيانات،  
  فإنها تُفقد عند إعادة تحميل الصفحة أو إعادة تشغيل الخادم.

**الحل:** أي بيانات يُراد استمرارها يجب أن تُرسَل إلى الخادم وتُكتب في جدول في DB ثم يُستدعى `commit()`.

---

## 3. الحلول العملية لمشكلتك الحالية

### 3.1 تحليل السبب الجذري

1. **التحقق من المسار الفعلي لقاعدة البيانات:**
   - في `config.py`: المسار الافتراضي هو `instance/accounting_app.db` (داخل جذر المشروع).
   - التأكد من عدم استخدام `:memory:` أو `/tmp` في بيئة التشغيل الفعلية.

2. **التحقق من وجود البيانات في القرص:**
   - بعد «حفظ» من الواجهة، التحقق من أن الجدول المعني في ملف `accounting_app.db` يحتوي على السجل الجديد (مثلاً عبر `sqlite3` أو استعلام من التطبيق).

3. **التحقق من المسار (route) الذي ينفّذ الحفظ:**
   - التأكد من أن هذا المسار يستدعي `db.session.add()` (أو ما يعادله) ثم **`db.session.commit()`** في مسار النجاح.
   - إذا كان الحفظ يتم عبر أكثر من جدول، يُفضّل استخدام **transaction واحد** (commit مرة واحدة بعد كل التعديلات).

### 3.2 إضافة / ضمان آلية الحفظ الصحيح

- **كل تعديل** في الشاشة يجب أن ينتهي بطلب إلى الخادم يحدّث الجدول ثم يستدعي `commit()`.
- استخدام **Transaction:** إذا كانت العملية تمس أكثر من جدول، تنفيذ كل التعديلات ثم `commit()` مرة واحدة؛ عند أي فشل استدعاء `rollback()` وعدم الـ commit.

### 3.3 إدارة تغييرات الموديل (Schema)

- عند **أي تعديل** في قاعدة البيانات (إضافة عمود، إعادة تسمية، إلخ):
  - إنشاء **migration script** (مثلاً Flask-Migrate أو سكربت مخصص) لترحيل البيانات من الحقول القديمة إلى الجديدة.
  - **عدم حذف** الحقول القديمة إلا بعد الترحيل والتحقق من اكتمال البيانات في الوجهة الجديدة.

### 3.4 تحذير المستخدم عند العمليات الخطرة

- أي عملية قد تؤدي إلى **فقدان البيانات** (مثل: إعادة تهيئة، حذف جماعي، استبدال استيراد) يجب أن تتطلب **تأكيداً صريحاً** من المستخدم (مثلاً نافذة تأكيد أو إدخال كلمة مرور).

---

## 4. ما يطبّقه هذا المشروع حالياً

| البند | الحالة |
|-------|--------|
| مسار SQLite | ✅ مسار ثابت: `instance/accounting_app.db` (أو `LOCAL_SQLITE_PATH`) — لا استخدام لـ `:memory:` أو `/tmp` في التشغيل العادي |
| الـ commit في المسارات | ✅ معظم مسارات الحفظ (إضافة فاتورة، قيد، إعدادات، إلخ) تستدعي `db.session.commit()` بعد النجاح |
| النسخ الاحتياطي | ✅ سكربت `scripts/backup_sqlite_db.py` لنسخ احتياطي يدوي إلى `backup/` |
| التوثيق | ✅ `docs/SQLITE_PERSISTENCE.md` يوضح المسار والـ commit والنسخ الاحتياطي |

**ملاحظة:** Flask-SQLAlchemy **لا يلتزم تلقائياً** في نهاية الطلب. أي مسار جديد أو تعديل على مسار قديم يجب أن يضمن استدعاء `db.session.commit()` بعد الكتابة في DB حتى لا تُفقد التعديلات عند إعادة تشغيل الخادم أو انتهاء الطلب.

---

## 5. تشخيص سريع: لماذا تُفقد بياناتي بعد إعادة تشغيل الخادم؟

اتبع الخطوات التالية للتحقق من السبب:

### 5.1 التأكد من مسار قاعدة البيانات الفعلي

- عند تشغيل التطبيق، المسار المستخدم يأتي من `config.py`:
  - الافتراضي: `instance/accounting_app.db` (ضمن مجلد المشروع).
  - إذا وُجد المتغير `LOCAL_SQLITE_PATH` في البيئة، يُستخدم هذا المسار بدلاً منه.
- **تحقق:** ابحث في الـ log عند بدء التشغيل إن وُجد سطر يطبع مسار DB، أو أضف مؤقتاً في `config.py` بعد تعريف `_default_sqlite_path`:
  - `print("DB path:", _default_sqlite_path)` ثم أعد تشغيل الخادم وتأكد أن المسار ثابت وليس `:memory:` أو داخل `/tmp`.

### 5.2 التأكد أن الحفظ يصل إلى القرص

1. بعد تنفيذ عملية «حفظ» من الواجهة (مثلاً إضافة فاتورة أو قيد)، **قبل إعادة تشغيل الخادم**:
   - افتح ملف `instance/accounting_app.db` بأداة SQLite (أو نفّذ: `sqlite3 instance/accounting_app.db "SELECT COUNT(*) FROM journal_entries;"` من جذر المشروع).
   - تحقق أن السجل الجديد موجود في الجدول المناسب.
2. إذا **البيانات موجودة قبل إعادة التشغيل** ولكن **تختفي بعد إعادة التشغيل**:
   - غالباً الخادم بعد إعادة التشغيل يقرأ من **ملف DB آخر** (مثلاً لأن `LOCAL_SQLITE_PATH` أو مجلد العمل مختلف).
   - تحقق أنك تشغّل التطبيق دائماً من **نفس المجلد** ونفس متغيرات البيئة.
3. إذا **البيانات غير موجودة حتى قبل إعادة التشغيل**:
   - السبب عادة أن الطلب الذي يفترض أن يحفظ **لم يستدعِ `commit()`** أو حدث **استثناء قبل الـ commit**.
   - راجع المسار (route) المسؤول عن هذا الحفظ وتأكد من وجود `db.session.commit()` بعد `add()`/`merge()` في مسار النجاح.

### 5.3 خلاصة التشخيص

| الحالة | السبب المحتمل | الإجراء |
|--------|----------------|----------|
| البيانات تظهر في DB قبل إعادة التشغيل وتختفي بعده | قراءة من ملف DB مختلف بعد إعادة التشغيل | توحيد مسار DB وطريقة تشغيل الخادم (نفس cwd و env) |
| البيانات لا تظهر في DB حتى قبل إعادة التشغيل | عدم استدعاء `commit()` أو استثناء قبل الـ commit | مراجعة route الحفظ وإضافة/ضمان `commit()` |
| استخدام `:memory:` أو سكربت اختبار | قاعدة بيانات في الذاكرة تُمسح عند الإغلاق | عدم استخدام `sqlite:///:memory:` في التشغيل العادي؛ استخدام `instance/accounting_app.db` |

---

## 6. خلاصة

- **النظام المثالي:** حفظ تلقائي في الجدول المعتمد، مع `commit()` بعد كل تعديل؛ وتغيير الـ schema عبر migrations مع ترحيل البيانات؛ والتراجع فقط بإرادة المستخدم.
- **لماذا تُفقد البيانات أحياناً:** غالباً بسبب عدم استدعاء `commit()`، أو استثناء قبل الـ commit، أو استخدام DB في الذاكرة/مؤقت، أو حفظ التعديلات فقط في الواجهة/الجلسة دون الكتابة في DB.
- **الحل العملي:** التأكد من مسار DB ثابت، واستدعاء `db.session.commit()` بعد كل عملية حفظ ناجحة، واستخدام transactions عند الحاجة، وعدم حذف حقول قديمة إلا بعد migration، وطلب تأكيد المستخدم للعمليات الخطرة.

---

## 7. النقاط الجوهرية المستخلصة — مرجع سريع

### الحفظ التلقائي

- أي تعديل يجب أن **يُحفظ مباشرة في قاعدة البيانات**، وليس فقط في الواجهة أو الجلسة.
- **`db.session.commit()`** بعد كل عملية ناجحة ضروري لإبقاء البيانات دائمة.

### تغييرات الموديل (Schema) بدون فقدان البيانات

- يجب إنشاء **migration scripts** لترحيل البيانات القديمة إلى الحقول الجديدة.
- **لا يجوز** حذف أي حقل قبل الترحيل والتحقق من أن البيانات محفوظة في الوجهة الجديدة.

### التراجع فقط بإرادة المستخدم

- إعادة تحميل الشاشة أو إعادة تشغيل الخادم **لا يجب** أن تحذف التعديلات (لأنها محفوظة في DB).
- التراجع يتم **فقط** عند ضغط زر «تراجع» أو «Reset» من المستخدم.

### أسباب فقدان البيانات الشائعة

| السبب | الوصف |
|-------|--------|
| عدم استدعاء `commit()` | التعديل يبقى في الـ session ولا يُكتب على القرص. |
| استثناء قبل `commit()` | الجلسة تُرجع (rollback) دون حفظ. |
| قاعدة بيانات مؤقتة أو في الذاكرة | `:memory:` أو `/tmp` — تُمسح عند الإغلاق أو إعادة التشغيل. |
| تغيير مجلد العمل (cwd) | يؤدي لقراءة/كتابة ملف DB مختلف. |
| حفظ التعديلات فقط في الواجهة أو الجلسة | دون إرسالها للـ DB. |

### حلول عملية

- التأكد من **مسار قاعدة بيانات ثابت** (مثل `instance/accounting_app.db`).
- ضمان أن **كل route** الذي يحفظ البيانات يستدعي **`commit()`** بعد النجاح.
- استخدام **transactions** عند تعديل عدة جداول (تعديلات ثم `commit()` مرة واحدة؛ عند فشل `rollback()`).
- إنشاء **migrations** عند تعديل الـ schema؛ عدم حذف حقول قديمة إلا بعد الترحيل.
- طلب **تأكيد صريح** من المستخدم عند عمليات قد تؤدي لفقدان البيانات (إعادة تهيئة، حذف جماعي، إلخ).

---

## 8. خطوات التشخيص والإصلاح

### 8.1 مراجعة سجل السيرفر (Server logs)

- في Flask، عند حدوث خطأ في API (مثل `GET /financials/api/operations/outstanding`) ابحث في الـ **stack trace** عن السبب المباشر: `KeyError`, `AttributeError`, `OperationalError`, `IntegrityError` إلخ.
- واجهة **المستحقات** (`api_operations_outstanding`) تسجّل الآن الاستثناءات عبر `logger.exception()` مع `party_type`, `party_id`, `party_name` لتسهيل التشخيص.

### 8.2 اختبار الاستعلام في قاعدة البيانات مباشرة

- **ملاحظة:** في هذا المشروع **المتبقي (remaining)** يُحسب من الكود وليس عموداً في الجدول:  
  `remaining = total_after_tax_discount - SUM(payments.amount_paid)`.
- لاختبار فواتير المشتريات غير المسددة لمورد معيّن (مثلاً `supplier_id = 1`):

```sql
-- فواتير المشتريات للمورد 1
SELECT id, invoice_number, date, supplier_id, supplier_name, total_after_tax_discount
FROM purchase_invoices
WHERE supplier_id = 1 OR supplier_name LIKE '%الهاجري%';

-- المبالغ المدفوعة لكل فاتورة (نوع purchase)
SELECT invoice_id, SUM(amount_paid) AS paid
FROM payments
WHERE invoice_type = 'purchase'
GROUP BY invoice_id;
```

- إذا نفذت الاستعلامات بنجاح والبيانات موجودة → المشكلة قد تكون في شرط الربط أو في الواجهة. إذا فشل (مثلاً "no such column") → المشكلة في الـ schema أو الحقل المفقود.

### 8.3 التأكد من صحة الربط بين الجداول

- **الفاتورة (purchase_invoices)** ↔ **المستحقات (شاشة العمليات)** ↔ **المورد (suppliers)**  
  يجب أن تحتوي:
  - `purchase_invoices`: `supplier_id` (اختياري)، `supplier_name` (اختياري)، `total_after_tax_discount`
  - `payments`: `invoice_type = 'purchase'`, `invoice_id` = id الفاتورة
  - `suppliers`: `id`, `name`  
  العلاقة: اختيار المورد في الشاشة يمرّر `party_id` (supplier_id) و/أو `party_name`؛ الـ API يجد الفواتير بـ `supplier_id` أو بالاسم (مع fallback بأول كلمة من الاسم).

### 8.4 التعامل مع الحالات الخاطئة في الكود

- تمت إضافة **try/except** حول منطق واجهة المستحقات مع تسجيل الاستثناء كاملاً (`logger.exception`) وإرجاع **JSON** عند الخطأ:  
  `return jsonify({'ok': False, 'error': str(e)}), 500`  
  حتى تستطيع الواجهة عرض رسالة خطأ منسقة بدلاً من صفحة HTML.
- عند إضافة استعلامات جديدة، يُفضّل لفّها بـ try/except وتسجيل الخطأ ثم إرجاع استجابة مناسبة (مثلاً قائمة فارغة أو 500 مع رسالة واضحة).
